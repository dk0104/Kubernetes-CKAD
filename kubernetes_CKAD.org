#+TITLE: Kubernetes CKAD
* Certification nontes
- use --dry-run=client
- use -o yaml to create resource definition file
- read  [[https://kubernetes.io/docs/reference/kubectl/conventions/][conventions]]
- use explain commands
  #+BEGIN_SRC
  kubectl explain <opject> --recursive
  #+END_SRC
-  Avoid running "kubectl edit pod <pod name>" use "kubectl get pod <name> -o yaml > <name>.yaml" instead
- some useful imperative commands
  | command                                                                     | description       |
  |-----------------------------------------------------------------------------+-------------------|
  | kubectl run nginx --image=nginx                                             | create [[Deployment]] |
  | kubectl run nginx --image=nginx --restart=Never                             | create [[Pod]]        |
  | kubectl run nginx --image=nginx --restart=OnFailure                         | create [[Job]]        |
  | kubectl run nginx --image=nginx  --restart=OnFailure --schedule="* * * * *" | create cronJob    |
  |                                                                             |                   |


** [[Service]]

#+BEGIN_QUOTE
An abstract way to expose an application running on a set of Pods as a network service.
With Kubernetes you don't need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them.
#+END_QUOTE


Create a Service named redis-service of type ClusterIP to expose pod redis on port 6379
#+BEGIN_SRC
kubectl expose pod redis --port=6379 --name redis-service --dry-run=client -o yaml
#+END_SRC
(This will automatically use the pod's labels as selectors)

Or
#+BEGIN_SRC
kubectl create service clusterip redis --tcp=6379:6379 --dry-run=client -o yaml
#+END_SRC
(This will not use the pods labels as selectors, instead it will assume selectors as app=redis. You cannot pass in selectors as an option. So it does not work very well if your pod has a different label set. So generate the file and modify the selectors before creating the service)

Create a Service named nginx of type NodePort to expose pod nginx's port 80 on port 30080 on the nodes:
#+BEGIN_SRC
kubectl expose pod nginx --port=80 --name nginx-service --type=NodePort --dry-run=client -o yaml
#+END_SRC
(This will automatically use the pod's labels as selectors, but you cannot specify the node port. You have to generate a definition file and then add the node port in manually before creating the service with the pod.)

Or

#+BEGIN_SRC
kubectl create service nodeport nginx --tcp=80:80 --node-port=30080 --dry-run=client -o yaml
#+END_SRC

(This will not use the pods labels as selectors)
Both the above commands have their own challenges. While one of it cannot accept a selector the other cannot accept a node port. I would recommend going with the `kubectl expose` command. If you need to specify a node port, generate a definition file using the same command and manually input the nodeport before creating the service

* kubectl api
[[https://kubernetes.io/docs/reference/kubectl/cheatsheet/][Kubernetes docs cheat sheet ]]
** delete
| command                                    |                          |
|--------------------------------------------+--------------------------|
| kubectl delete pod <name> --grace-period=0 | Delete pod with no delay |
|                                            |                          |

** run

| command                                                                     | description            |
|-----------------------------------------------------------------------------+------------------------|
| kubectl run nginx --image=nginx                                             | create [[Deployment]]      |
| kubectl run nginx --image=nginx --restart=Never                             | create [[Pod]]             |
| kubectl run nginx --image=nginx --restart=OnFailure                         |                        |
| kubectl run nginx --image=nginx  --restart=OnFailure --schedule="* * * * *" | create cronJob         |
| kubectl run <name> --image=<image> --restart=Never -it --rm --echo "tex"    | create and send output |
| kubectl run <name> --image=<image> --labes=<label key>=<label val>          | create pod with labels |
|                                                                             |                        |

** exec

| Description             | Command                                 |
|-------------------------+-----------------------------------------|
| Exec into the pod       | kubectl exec --it <name> /bin/sh        |
| Run command on multipod | kubectl exec <name> -c <container name> |
|                         |                                         |

** create

| Description        | Command                                           |
|--------------------+---------------------------------------------------|
| Create deployment  | kubectl create deployment <name> --image=<image>  |
| Create secret      | kubectl create secret generic dev-db-secret \     |
|                    | --from-literal=username=devuser \                 |
|                    | --from-literal=password='S!B\*d$zDsb='            |
| Create secret file | kubectl create secret genereic --from-file=<path> |
|                    |                                                   |

*** Generators
| kubectl create <genereator> --dry-run=client -o yaml |                                                                   |
| clusterrole                                          | Create a ClusterRole.                                             |
| clusterrolebinding                                   | Create a ClusterRoleBinding for a particular ClusterRole.         |
| configmap                                            | Create a configmap from a local file, directory or literal value. |
| cronjob                                              | Create a cronjob with the specified name.                         |
| deployment                                           | Create a deployment with the specified name.                      |
| job                                                  | Create a job with the specified name.                             |
| namespace                                            | Create a namespace with the specified name.                       |
| poddisruptionbudget                                  | Create a pod disruption budget with the specified name.           |
| priorityclass                                        | Create a priorityclass with the specified name.                   |
| quota                                                | Create a quota with the specified name.                           |
| role                                                 | Create a role with single rule.                                   |
| rolebinding                                          | Create a RoleBinding for a particular Role or ClusterRole.        |
| secret                                               | Create a secret using specified subcommand.                       |
| service                                              | Create a service using specified subcommand.                      |
| serviceaccount                                       | Create a service account with the specified name.                 |
|                                                      |                                                                   |

** describe

| Description | Command |
|-------------+---------|
|             |         |

** get

get pod,pods, pv ,services,node,nodes,events,
| Description                            | Command                                                           |
|----------------------------------------+-------------------------------------------------------------------|
| Show secrets                           | kubectl get secrets                                               |
| Check the image version                | kubectl get pod <name> -o jsonpath='.spec.containers[].image{"\n} |
| list sorted                            | kubectl get pods--sort-by=.metadata.creationTimestamp             |
| Get pods with labels                   | kubectl get pods --show-labels                                    |
| Get pod with sertain labels            | kubectl get pods -l <label val>=<label key> --show labels         |
| Get pods with label keys               | kubectl get pods -L env                                           |
| Get pods with multi label key val pair | kubectl get pods -l '<label key> in <val1,val2>' --show-labels    |
|                                        |                                                                   |

** edit

| Description                        | Command                        |
|------------------------------------+--------------------------------|
| Edit pod (not ediatble if running) | kubectl edit pod<name>         |
| Edit deployment                    | kubectl edit deployment <name> |

** logs

| Description             | Command                                 |
|-------------------------+-----------------------------------------|
| logs multiple contaiers | kubectl logs <name> -c <container name> |
|                         |                                         |
|                         |                                         |
|                         |                                         |

** label

| Description      | Command                                  |
|------------------+------------------------------------------|
| change the label | kubectl label <name> env=uat --overwrite |
|                  |                                          |

* Core Concepts
** Node
- Apply lable on the nodes
** [[Deployment]]
Orig link: [[https://kubernetes.io/docs/concepts/services-networking/service/][Service]]

#+BEGIN_QUOTE
A Deployment provides declarative updates for Pods ReplicaSets.

You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments.
#+END_QUOTE

example file
#+BEGIN_SRC

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
     app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
       app: nginx
  template:
    metadata:
      labels:
        app: nginx
  spec:
    containers:
    - name: nginx
      image: nginx:1.14.2
      ports:
        - containerPort: 80
#+END_SRC

** [[Pod]]
- Create imperative pod
  #+BEGIN_SRC
  kubectl run <name> --image=<image>
  #+END_SRC
- Create imperative podfile
  #+BEGIN_SRC
  `kubectl run <name> --image=<image> --dry-run=client -o yaml``
  #+END_SRC
** Namespace
Doc link: [[https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/][Namespace]]
#+BEGIN_QUOTE
Kubernetes supports multiple virtual clusters backed by the same physical cluster. These virtual clusters are called namespaces.
#+END_QUOTE

How to use:

#+BEGIN_SRC shell

"List namespaces in cluster:"
kubectl get namespace

"Get elleenst for all namespaces"
kubectl get all -A

"Setting the namespace for a request"
kubectl run <name> --image=<image> --namespace=<namespace>
#+END_SRC

#+RESULTS:

** Deployment
[[https://kubernetes.io/docs/concepts/workloads/controllers/deployment/][Deployment]]
#+BEGIN_QUOTE
A Deployment provides declarative updates for Pods ReplicaSets.

You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments.
#+END_QUOTE

example file
#+BEGIN_SRC

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
     app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
       app: nginx
  template:
    metadata:
      labels:
        app: nginx
  spec:
    containers:
    - name: nginx
      image: nginx:1.14.2
      ports:
        - containerPort: 80
#+END_SRC

- create simple deployment
  #+BEGIN_SRC
  kubectl create deployment --image=<image> <name>
  #+END_SRC
- create simple deploymentfile
  #+BEGIN_SRC
  `kubectl create deployment --image=<image> <name> --dry-run=client -o yaml > <filename>
  #+END_SRC
- Important no replicas param use "kubectl scale" instead
** Service
[[https://kubernetes.io/docs/concepts/services-networking/service/][Service]]

#+BEGIN_QUOTE
An abstract way to expose an application running on a set of Pods as a network service.
With Kubernetes you don't need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them.
#+END_QUOTE

*** How to use :
#+BEGIN_SRC yaml
apiVersion: v1


#+END_SRC

* Configuration
** Command and Arguments
- Doc link: [[https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/][Define a Command and Arguments for Container]]

#+BEGIN_SRC yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: command-demo
    labels:
      purpose: demonstrate-command
  spec:
    containers:
    - name: command-demo-container
      image: debian
      command: ["printenv"]
      args: ["HOSTNAME", "KUBERNETES_PORT"]
    restartPolicy: OnFailure

  #+END_SRC

** Config Maps
Doc link: [[https://kubernetes.io/docs/concepts/configuration/configmap/][ConfigMaps]]

#+BEGIN_QUOTE
A ConfigMap is an API object used to store non-confidential data in key-value pairs. Pods can consume ConfigMaps as environment variables, command-line arguments, or as configuration files in a volume.
A ConfigMap allows you to decouple environment-specific configuration from your container images, so that your applications are easily portable.
#+END_QUOTE

*** How to create config maps:
- Imperative
 #+BEGIN_SRC shell

"create configmapi literal"
kubectl create configmap <config-name> --from-literal=<key>=<value>

"create configmap config file"
kubectl create configmap <config-name> --from-file=<path-to-file>


 #+END_SRC

- Declarative

#+BEGIN_SRC yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: game-demo
data:
  # property-like keys; each key maps to a simple value
  player_initial_lives: "3"
  ui_properties_file_name: "user-interface.properties"

  # file-like keys
  game.properties: |
    enemy.types=aliens,monsters
    player.maximum-lives=5
  user-interface.properties: |
    color.good=purple
    color.bad=yellow
    allow.textmode=true

#+END_SRC
#+BEGIN_SRC shell
kubectl create -f <filename>
#+END_SRC

*** How to inject config maps
#+BEGIN_SRC
"show exitsting maps"
 kubectl get configmaps

"describe map"
kubectl describe configmaps

#+END_SRC

- Inject to pod's
  + Inject config file
#+BEGIN_SRC yaml
apiVersion: v1
kind: Pod
metadata:
spec:
 containers:
  envFrom:
    - configMapRef:
       name: <config name>

#+END_SRC
  + Inject singe config

#+BEGIN_SRC yaml
apiVersion: v1
kind: Pod
metadata:
spec:
 containers:
  envFrom:
    - configMapKeyRef:
       name: <config name>
       key: <key>
#+END_SRC

** Environment Variable
** Replica Sets
** Security Context
** Secret
[[https://kubernetes.io/docs/concepts/configuration/secret/][Secret]]
#+BEGIN_QUOTE
Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. See Secrets design document for more information
#+END_QUOTE
*** how to use:
**** Imperative Way to create secrets:

#+BEGIN_SRC
kubectl create secret generic dev-db-secret \
    --from-literal=username=devuser \
    --from-literal=password='S!B\*d$zDsb='
#+END_SRC

#+BEGIN_SRC
kubectl create secret generic dev-db-secret \
    --from-file=<path to file>
#+END_SRC

**** Declarative way to create secrets:
#+BEGIN_SRC
apiVersion: v1
kind: Secret
metadata:
  name: app-secret

data:
  <Key>: <value>
#+END_SRC

kubectl create -f <filename>

*** Simple way to encrypt secret using Base64 encryption
#+BEGIN_SRC shell
 echo -n <value> | base64
#+END_SRC

*** View secrets:
#+BEGIN_SRC  shell

"Show secrets       "
kubectl get secrets

"describe secrets"
kubectl describe secrets

"show secret values "
kubectl get secret app-secret -o yaml
#+END_SRC

#+RESULTS:

*** Pod integration
#+BEGIN_SRC yaml
apiVersion: v1
kind: Pod

spec:
  containers:
    envFrom:
      - secretRef:
          name: <secret:name>

#+END_SRC
Secrets could be injected as Single value Environment variable or volume.

** Service Accounts
** Taints and Tolerations
Doc link:  [[https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/][Taints and toleration]]
#+BEGIN_QUOTE
Node affinity, is a property of Pods that attracts them to a set of nodes (either as a preference or a hard requirement). Taints are the opposite -- they allow a node to repel a set of pods.
Tolerations are applied to pods, and allow (but do not require) the pods to schedule onto nodes with matching taints.
Taints and tolerations work together to ensure that pods are not scheduled onto inappropriate nodes. One or more taints are applied to a node; this marks that the node should not accept any pods that do not tolerate the taints.
#+END_QUOTE

- How to:
  - Taint Node
    #+BEGIN_SRC
    kubctl taint nodes node-name key=value:taint-effect
    #+END_SRC
    Taint-effect
    | NoSchedule       | avoid placing the node on the pod             |
    | PreferNoSchedule | try to avoid placing the pod on the node      |
    | NoExecute        | Avoid new pods, existing pods will be evicted |
  - Apply tolarations to pods
    #+BEGIN_SRC yaml
    apiVersion: v1
    spec:
      tolarations:
      - key:"<key>"
        operator:"<operator>"
        value: "<value>"
    #+END_SRC

** Resource Request
** Node Selectors
** Node Affinity
Operators :
|              |   |
|--------------+---|
| In           |   |
| NotIn        |   |
| Exists       |   |
| DoesNotExist |   |
| Gt           |   |
| Lt           |   |

** Pods+

* Observability
** Monitoring and Debug
** Logs
** Readiness and Liveness Probes
** Container Logging
** Liveness Probes
* Pod Design
** Labels and Selectors
[[https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/][Labels and Selectors]]
#+BEGIN_QUOTE
Labels are key/value pairs that are attached to objects, such as pods. Labels are intended to be used to specify identifying attributes of objects that are meaningful and relevant to users, but do not directly imply semantics to the core system. Labels can be used to organize and to select subsets of objects. Labels can be attached to objects at creation time and subsequently added and modified at any time. Each object can have a set of key/value labels defined. Each Key must be unique for a given object.
#+END_QUOTE

Main reason for filtering ( Bridge tags filters )

*** How to use:
- Filter manually
    #+BEGIN_SRC
    kubectl get pods --selector <label key>=<label val>
    #+END_SRC
- Address pods on replica sets
  Replica set definiton file
  #+BEGIN_SRC
  apiVersion: apps/v1
  kind: ReplicaSet
  ...
  spec:
    replicas: <num of replicas>
    selector:
      matchLabels:
        app: App1             | -> Connect replica sets to the pod
    template:
      metadata:
        labels:
          app: App1
          function: Front-end | -> Pod labels

  #+END_SRC

** Init Containers
- kubernetes doc ref: [[https://kubernetes.io/docs/concepts/workloads/pods/init-containers/][Init Containers]]

  #+BEGIN_QUOTE
  This page provides an overview of init containers: specialized containers that run before app containers in a Pod. Init containers can contain utilities or setup scripts not present in an app image.
  You can specify init containers in the Pod specification alongside the containers array (which describes app containers).
  #+END_QUOTE


#+BEGIN_SRC
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox:1.28
    command: ['sh', '-c', 'echo The app is running! && sleep 3600']
  initContainers:
  - name: init-myservice
    image: busybox:1.28
    command: ['sh', '-c', "until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done"]
  - name: init-mydb
    image: busybox:1.28
    command: ['sh', '-c', "until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done"]
#+END_SRC

** Jobs / Cron Jobs
Doc link :[[https://kubernetes.io/docs/concepts/workloads/controllers/job/][Jobs ]]
Doc link [[https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/][Cron Jobs]]:
- Jobs are ment to perform some tastks -> Pods in order to completion and not for ever like ReplicaSets
*** How to create a job
- Pod definition
#+BEGIN_SRC
apiVersion: v1
kind: Pod
metadata:
name: math-pod
spec:
  containers:
    - name:
      image:
      command: []
restartPolicy: Never                | Kubernetes does not restart the container
#+END_SRC


- Job definition
#+BEGIN_SRC
apiVersion: batch/v1                | May be changed
kind: Job
metadata:
name: math-pod
spec:
  completions: <number of inst>       | only number of comnl runs count
  parallelism: <num>                  | completed parallel
template:
    spec:
    containers:
        - name:
          image:
          command: []
    restartPolicy: Never
#+END_SRC

*** How to use jobs
| Command                               | Description                    |
|---------------------------------------+--------------------------------|
| kubectl create -f job-definition.yaml | Create job with definition     |
| kubectl get jobs                      | List created jobs              |
| kubectl delete job <name>             | Delete job                     |
| kubectl logs <pod>                    | Job output standard pod output |
|                                       |                                |

** Rolling updates and Rollback in Deployment
*** Rollout and versioning
- Deployment strategy

*** Examles
| Command                                   | Description                     |
|-------------------------------------------+---------------------------------|
| kubectl rollout status <deployment name>  | Shows current deployment status |
| kubectl rollout history <deployment name> | Shows deployment history        |
| kubectl apply -f <depl definition file>   | Pod changed -> rollout trigger  |
* Secvices and Networking
** Network Policy
[[https://kubernetes.io/docs/concepts/services-networking/network-policies/][NetworkPolicy]]

#+BEGIN_QUOTE
If you want to control traffic flow at the IP address or port level (OSI layer 3 or 4), then you might consider using Kubernetes NetworkPolicies for particular applications in your cluster. NetworkPolicies are an application-centric construct which allow you to specify how a pod is allowed to communicate with various network "entities" (we use the word "entity" here to avoid overloading the more common terms such as "endpoints" and "services", which have specific Kubernetes connotations) over the network.

The entities that a Pod can communicate with are identified through a combination of the following 3 identifiers:

Other pods that are allowed (exception: a pod cannot block access to itself)
Namespaces that are allowed
IP blocks (exception: traffic to and from the node where a Pod is running is always allowed, regardless of the IP address of the Pod or the node)
When defining a pod- or namespace- based NetworkPolicy, you use a selector to specify what traffic is allowed to and from the Pod(s) that match the selector.

Meanwhile, when IP based NetworkPolicies are created, we define policies based on IP blocks (CIDR ranges).
#+END_QUOTE

- Examles:
#+BEGIN_SRC
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: test-network-policy
  namespace: default
spec:
  podSelector:
  matchLabels:
    role: db
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - ipBlock:
        cidr: 172.17.0.0/16
        except:
        - 172.17.1.0/24
    - namespaceSelector:
        matchLabels:
          project: myproject
    - podSelector:
        matchLabels:
          role: frontend
    ports:
    - protocol: TCP
    port: 6379
  egress:
  - to:
    - ipBlock:
        cidr: 10.0.0.0/24
    ports:
    - protocol: TCP
      port: 5978
#+END_SRC

* State Presistance
** Persistent Volumes
[[https://kubernetes.io/docs/concepts/storage/persistent-volumes/][Persistent Volumes]]
** Persistent Volume Claims
[[https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims][Persistant volume claim]]

#+BEGIN_SRC yalm
apiVersion:v1
kind: PersistentVolumeClaim
metadata:
  name: myclaim
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Filesystem
  resources:
    requests:
       storage: 8Gi
  storageClassName: slow
  selector:
    matchLabels:
      release: "stable"
    matchExpressions:
      - {key: environment, operator: In, values: [dev]}

#+END_SRC

* Tool ideas etc.
** Bash alias entries
#+BEGIN_SRC sh
alias k='kubectl'
alias c='k create'
alias d='k delete'
alias de='k describe'
alias e='k edit'
alias r='k run'
alias roll='k rollout'
#+END_SRC
start autocomplition :
#+BEGIN_SRC shell
 complete -F __start_kubectl k
#+END_SRC
** Vimrc settings
#+BEGIN_SRC vimrc
  set ts=2 sw=2 expandtab
  set nu
** Used Cli Tools
*** Netcat
[[https://linuxize.com/post/netcat-nc-command-with-examples/][nc examples]]
- Scan for open ports
nc -z -v <service name> <port>

#+END_SRC
**  TODO:
 [X] Read [[https://kubernetes.io/docs/tasks/administer-cluster/declare-network-policy/][Declare Network Polilcy]]

* Exercise notes
** Game of Pods
*** Drupal cms
Create Service file:

#+BEGIN_SRC
k create service nodeport drupal-service --node-port=30095 --tcp=80 --dry-run=true -o yaml > drupal_service.yaml
#+END_SRC

- [X] TODO: Read about[[https://kubernetes.io/docs/concepts/workloads/pods/init-containers/][ Init Containers]]

** Test Mock 2
- [ ] Find out if the servce can be created vie cli
- [-] Repeat Taints and Toleratons
